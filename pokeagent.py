"""PokeAgent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FdDZUUumQLxPMdZPcdtxIvFAQPb6xmuO
"""

import math
import requests
import random
import csv
import gym

import numpy as np
import copy

from gym import spaces


class Pokemon:

    _SPECIES_CACHE = {}
    _TYPE_CACHE    = {}

    def __init__(self, name, moves, level=100, use_cache=True):
        self.name  = name.lower().replace(" ", "-")
        self.level = level

        self.moves = [mv.clone_fresh() for mv in moves]

        self._load_species_data(use_cache)

        self.just_switched = False
        self._init_battle_state()

    def clone_fresh(self):

        for move in self.moves:
            move = move.clone_fresh()
        return Pokemon(self.name, self.moves, self.level, use_cache=True)

    def take_damage(self, damage: int):

        self.damage_taken_last = max(0, damage)
        self.hp = max(0, self.hp - self.damage_taken_last)

    def is_fainted(self) -> bool:
        return self.hp <= 0

    def heal(self):
        self.hp = self.max_hp
        self.damage_taken_last = 0

    def get_matchup_multiplier(self, attacking_type: str) -> float:

        m = 1.0
        for t in (self.type1, self.type2) if self.type2 else (self.type1,):
            chart = Pokemon._TYPE_CACHE[t]
            if attacking_type in chart["double_damage_from"]:
                m *= 2.0
            elif attacking_type in chart["half_damage_from"]:
                m *= 0.5
            elif attacking_type in chart["no_damage_from"]:
                m *= 0.0
        return m

    def _init_battle_state(self):
        bp = self.base_stats
        L  = self.level

        self.max_hp   = math.floor(((2 * bp["hp"] * L) / 100) + L + 10)
        self.attack   = math.floor(((2 * bp["attack"]   * L) / 100) + 5)
        self.defense  = math.floor(((2 * bp["defense"]  * L) / 100) + 5)
        self.sp_attack   = math.floor(((2 * bp["sp_attack"]  * L) / 100) + 5)
        self.sp_defense   = math.floor(((2 * bp["sp_defense"] * L) / 100) + 5)
        self.speed    = math.floor(((2 * bp["speed"]    * L) / 100) + 5)

        self.hp                = self.max_hp
        self.damage_taken_last = 0

    def _load_species_data(self, use_cache: bool):

        if use_cache and self.name in Pokemon._SPECIES_CACHE:
            meta = Pokemon._SPECIES_CACHE[self.name]
        else:
            url = f"https://pokeapi.co/api/v2/pokemon/{self.name}"
            r   = requests.get(url, timeout=5)
            if r.status_code != 200:
                raise RuntimeError(f"Failed to fetch Pokémon '{self.name}'")
            data = r.json()

            types = [t["type"]["name"] for t in data["types"]]
            stats = { stat["stat"]["name"]: stat["base_stat"]
                      for stat in data["stats"] }

            meta = {
                "type1": types[0],
                "type2": types[1] if len(types) > 1 else None,
                "base_stats": {
                    "hp":            stats["hp"],
                    "attack":        stats["attack"],
                    "defense":       stats["defense"],
                    "sp_attack":     stats["special-attack"],
                    "sp_defense":    stats["special-defense"],
                    "speed":         stats["speed"],
                }
            }
            Pokemon._SPECIES_CACHE[self.name] = meta

        self.type1     = meta["type1"]
        self.type2     = meta["type2"]
        self.base_stats = meta["base_stats"]

        for t in (self.type1, self.type2) if self.type2 else (self.type1,):
            if t not in Pokemon._TYPE_CACHE:
                self._fetch_type_chart(t)

    def get_move_matchup_multiplier(self, other):

        move_multipliers = {}

        for move in self.moves:
            if move.is_status:
                continue
            attacker_type = move.type
            multiplier = other.get_matchup_multiplier(attacker_type)
            move_multipliers[move.name] = multiplier

        return move_multipliers

    def get_total_matchup_multiplier(self, other):

        type_mult_1 = other.get_matchup_multiplier(self.type1)
        type_mult_2 = other.get_matchup_multiplier(self.type2) if self.type2 else 1.0
        type_matchup = type_mult_1 * type_mult_2

        move_effectiveness = [
            other.get_matchup_multiplier(move.type)
            for move in self.moves if not move.is_status and hasattr(move, "type")
        ]
        if move_effectiveness:
            best_move_matchup = max(move_effectiveness)
        else:
            best_move_matchup = 0.5

        return 0.4 * type_matchup + 0.6 * best_move_matchup


    @staticmethod
    def _fetch_type_chart(t: str):
        url = f"https://pokeapi.co/api/v2/type/{t}"
        r   = requests.get(url, timeout=5)
        if r.status_code != 200:
            raise RuntimeError(f"Failed to fetch type chart for '{t}'")
        rel = r.json()["damage_relations"]
        Pokemon._TYPE_CACHE[t] = {
            "double_damage_from": [x["name"] for x in rel["double_damage_from"]],
            "half_damage_from":   [x["name"] for x in rel["half_damage_from"]],
            "no_damage_from":     [x["name"] for x in rel["no_damage_from"]],
        }

    def __str__(self):
        return (f"{self.name.title()} (Lv{self.level}) "
                f"[{self.type1}/{self.type2 or '--'}] "
                f"HP {self.hp}/{self.max_hp}")

class Move:
    _CACHE = {}

    def __init__(self, name, *, use_cache=True):
        self.name = name.lower().replace(" ", "-")
        self._load_data(use_cache)

        self.pp_remaining = self.pp
        self.is_used      = False

    def apply(self, attacker, defender):
        if self.pp_remaining == 0:
            raise RuntimeError(f"{self.name} is out of PP!")
        self.pp_remaining -= 1
        self.is_used = True

        dmg = self.calculate_damage(attacker, defender)
        defender.take_damage(dmg)
        defender.damage_taken_last = dmg
        attacker.damage_taken_last = 0
        return dmg

    def theoretical_damage(self, attacker, defender):
        return self._base_damage(attacker, defender) * \
               attacker.get_matchup_multiplier(self.type)

    def clone_fresh(self):
        return Move(self.name, use_cache=True)

    def __str__(self):
        return (f"{self.name} (Type {self.type}, Pow {self.power}, "
                f"Acc {self.accuracy}, PP {self.pp_remaining}/{self.pp})")

    def calculate_damage(self, attacker, defender):
        effectiveness = defender.get_matchup_multiplier(self.type)

        # STAB
        if self.type in (attacker.type1, attacker.type2):
            effectiveness *= 1.5

        rand = random.uniform(0.85, 1.0)

        return int(self._base_damage(attacker, defender) *
                   effectiveness * rand)

    def _base_damage(self, attacker, defender):
        atk_stat = attacker.sp_attack if self.is_special else attacker.attack
        def_stat = defender.sp_defense if self.is_special else defender.defense
        lvl      = attacker.level
        power    = self.power or 0

        return (((2 * lvl / 5 + 2) * power * (atk_stat / def_stat)) / 50) + 2

    def _load_data(self, use_cache):

        if use_cache and self.name in Move._CACHE:
            meta = Move._CACHE[self.name]
        else:
            meta = self._fetch_from_api(self.name)
            Move._CACHE[self.name] = meta

        self.type        = meta["type"]
        self.power       = meta["power"]
        self.accuracy    = meta["accuracy"]
        self.pp          = meta["pp"]
        self.is_status   = meta["is_status"]
        self.is_special  = meta["is_special"]
        self.is_physical = meta["is_physical"]

    @staticmethod
    def _fetch_from_api(name=None):
        """One real HTTP call; cached thereafter."""
        if name is None:
            raise ValueError("Move name required")
        url = f"https://pokeapi.co/api/v2/move/{name}"
        r   = requests.get(url, timeout=5)
        if r.status_code != 200:
            raise RuntimeError(f"Failed to fetch data for move '{name}'")

        data = r.json()
        dmg_class = data["damage_class"]["name"]

        return dict(
            type        = data["type"]["name"],
            power       = data["power"]     or 0,
            accuracy    = data["accuracy"]  or 100,
            pp          = data["pp"],
            is_status   = dmg_class == "status",
            is_special  = dmg_class == "special",
            is_physical = dmg_class == "physical",
        )

class StruggleMove(Move):
    """“Struggle” – invoked automatically when a mon has no PP left."""
    def __init__(self):
        super().__init__(
            name="struggle"
        )

    def _deduct_pp(self):
        pass

STRUGGLE_MOVE = StruggleMove()

class Trainer:
    def __init__(self, name, pokemon_team):
        self.name = name
        self.team = pokemon_team
        self.current_pokemon = pokemon_team[0]

    def get_active_pokemon(self):
        return [p for p in self.team if not p.is_fainted()]

    def count_usable_pokemon(self):
        return len(self.get_active_pokemon())

    def has_usable_pokemon(self):
        return any(not p.is_fainted() for p in self.team)

    def choose_action(self, opponent_pokemon):
        if not self.current_pokemon or not opponent_pokemon:
            return

        matchup = self.current_pokemon.get_total_matchup_multiplier(opponent_pokemon)

        if matchup < 1.0 and random.random() < 0.7:
            next_pokemon = self.switch_pokemon(opponent_pokemon, exclude=self.current_pokemon)

            if next_pokemon and next_pokemon != self.current_pokemon:
                self.current_pokemon = next_pokemon
            else:
                return self.current_pokemon.choose_move(opponent_pokemon)
        else:
            return self.current_pokemon.choose_move(opponent_pokemon)


    def switch_to(self, slot):
        self.current_pokemon = self.team[slot]

    def get_best_pokemon_idx(self, opponent):

        def get_score(slot):
            return self.team[slot].get_total_matchup_multiplier(opponent)

        alive_indices = [
            i for i, mon in enumerate(self.team)
            if not mon.is_fainted() and mon is not self.current_pokemon
        ]

        if not alive_indices:
            return None
        return max(alive_indices, key=get_score)

    def get_best_move(self, opponent):
        damage_moves = {
            move: move.calculate_damage(self.current_pokemon, opponent) for move in self.current_pokemon.moves if not move.is_status
        }

        move = max(damage_moves, key=damage_moves.get)
        return move

    def send_out_next_pokemon(self, opponent):
        next_pokemon_idx = self.get_best_pokemon_idx(opponent)
        next_pokemon = self.team[next_pokemon_idx] if next_pokemon_idx is not None else None

        if next_pokemon and next_pokemon != self.current_pokemon:
            self.switch_to(next_pokemon_idx)
        else:
            return None

    def send_out_first_pokemon(self):
        self.current_pokemon = self.team[0]

        return self.current_pokemon

    def clone_fresh(self):
        return Trainer(
            self.name,
            [mon.clone_fresh() for mon in self.team]
        )

class TrainerAgent(Trainer):
    def __init__(self, name, team, policy="scripted"):
        self.name  = name
        self.team  = team
        self.policy = policy
        self.current_pokemon = self.team[0]

    def choose_action(self, opponent):
        if self.policy == "learner":
            return None
        elif self.policy == "random":
            legal   = [m for m in self.current_pokemon.moves if m.pp_remaining > 0]
            return random.choice(legal)
        else:
            best = max(
                self.current_pokemon.moves,
                key=lambda mv: mv.theoretical_damage(self.current_pokemon, opponent)
            )
            return best

    def clone_fresh(self):
        return TrainerAgent(
            self.name,
            [mon.clone_fresh() for mon in self.team],
            self.policy
        )

TURN_PENALTY = 0.02

class BattleLogger(gym.Wrapper):
    def __init__(self, env, path="battle_log.csv", print_flag=False):
        super().__init__(env)
        self.path = path
        self._file = open(self.path, "a", newline="")
        self._writer = None
        self.print_flag = print_flag

    def reset(self, **kwargs):
        self._ep_reward = 0.0
        return super().reset(**kwargs)

    def step(self, action):
        obs, reward, done, trunc, info = self.env.step(action)
        self._ep_reward += reward

        if done or trunc:

            if self.print_flag:
                print(f"Episode reward: {self._ep_reward:.2f}")

            out = self.env.outcome()
            row = {
                "episode": info.get("episode"),
                **out,
                "reward": self._ep_reward
            }
            if self._writer is None:
                self._writer = csv.DictWriter(self._file, fieldnames=row.keys())
                if self._file.tell() == 0:
                    self._writer.writeheader()
            self._writer.writerow(row)
            self._file.flush()
        return obs, reward, done, trunc, info

class Cynthia(Trainer):
    def __init__(self, name="Cynthia"):
        self.team = [
            Pokemon("spiritomb", [Move("shadow-ball"), Move("dark-pulse"), Move("will-o-wisp"), Move("silver-wind")]),
            Pokemon("garchomp", [Move("earthquake"), Move("dragon-claw"), Move("stone-edge"), Move("flamethrower")]),
            Pokemon("lucario", [Move("close-combat"), Move("aura-sphere"), Move("extreme-speed"), Move("ice-punch")]),
            Pokemon("milotic", [Move("surf"), Move("ice-beam"), Move("recover"), Move("bulldoze")]),
            Pokemon("roserade", [Move("energy-ball"), Move("sludge-bomb"), Move("toxic-spikes"), Move("extrasensory")]),
            Pokemon("togekiss", [Move("air-slash"), Move("thunder-wave"), Move("roost"), Move("aura-sphere")])
        ]
        super().__init__(name, self.team)

class Dawn(TrainerAgent):
    def __init__(self, name="Dawn"):
        self.team = [
            Pokemon("infernape", [Move("flamethrower"), Move("close-combat"), Move("thunder-punch"), Move("earthquake")]),
            Pokemon("staraptor", [Move("brave-bird"), Move("close-combat"), Move("roost"), Move("steel-wing")]),
            Pokemon("electivire", [Move("thunderbolt"), Move("cross-chop"), Move("ice-punch"), Move("fire-punch")]),
            Pokemon("mamoswine", [Move("earthquake"), Move("icicle-crash"), Move("stone-edge"), Move("ancient-power")]),
            Pokemon("bronzong", [Move("extrasensory"), Move("earthquake"), Move("stealth-rock"), Move("flash-cannon")]),
            Pokemon("tentacruel", [Move("scald"), Move("sludge-bomb"), Move("toxic-spikes"), Move("ice-beam")])
        ]
        super().__init__(name, self.team)

TYPE2IDX = {
    "normal":   0,
    "fire":     1,
    "water":    2,
    "electric": 3,
    "grass":    4,
    "ice":      5,
    "fighting": 6,
    "poison":   7,
    "ground":   8,
    "flying":   9,
    "psychic":  10,
    "bug":      11,
    "rock":     12,
    "ghost":    13,
    "dragon":   14,
    "dark":     15,
    "steel":    16,
    "fairy":    17,
}

IDX2TYPE = {v: k for k, v in TYPE2IDX.items()}

STATE_VEC_DIMS = 37

class PokemonEnv(gym.Env):
    """
    A single-battle Pokémon environment (singles, no items, no weather).
    The learning agent always plays as trainer1; trainer2 can be scripted,
    random, or self-play.
    """
    metadata = {"render_modes": ["ansi"]}

    def __init__(self, trainer1, trainer2, max_turns=100, print_flag=False):
        super().__init__()

        self.t1 = trainer1
        self.t2 = trainer2

        self.turns = 0
        self.max_turns = max_turns

        self.action_space = spaces.Discrete(10)

        high = np.array([1.0] * STATE_VEC_DIMS, dtype=np.float32)
        self.observation_space = spaces.Box(low=0.0, high=high, dtype=np.float32)

        self.force_switch = False
        self.print_flag = print_flag

    def reset(self, *, seed=None, options=None):
        self.turns = 0
        super().reset(seed=seed)

        self.t1 = self.t1.clone_fresh()
        self.t2 = self.t2.clone_fresh()

        self.t1.send_out_first_pokemon()
        self.t2.send_out_first_pokemon()

        if self.print_flag:

            print(f"{self.t1.name} sends out {self.t1.current_pokemon.name}")
            print(f"{self.t2.name} sends out {self.t2.current_pokemon.name}")

        return self._encode_state(), {}

    def step(self, action: int):
        """
        One half-turn from the learning agent, followed by the opponent’s reply.
        """
        done = False
        reward = 0.0

        if self.force_switch:
            _, slot = None, action - 4
            self.t1.switch_to(slot)

            if self.print_flag:
                print(f"{self.t1.name} sent out {self.t1.current_pokemon.name}")

            self.force_switch = False
            self.turns += 1
            return self._encode_state(), reward, done, False, {
                "legal_actions": self.legal_actions(self.t1)
            }

        if self.print_flag:
            print(f"\n=== Turn {self.turns} ===")

        t1_current_pokemon_copy = copy.deepcopy(self.t1.current_pokemon)
        t2_current_pokemon_copy = copy.deepcopy(self.t2.current_pokemon)

        opp_alive_before   = self.t2.count_usable_pokemon()
        agent_alive_before = self.t1.count_usable_pokemon()

        t1_move, t1_next_slot = self._execute_action(self.t1, action)

        if t1_next_slot is not None:
            self.t1.switch_to(t1_next_slot)

        opp_fainted = not self.t2.has_usable_pokemon()
        agent_fainted = not self.t1.has_usable_pokemon()


        t2_move, t2_next_slot = None, None
        if not (opp_fainted or agent_fainted):
            t2_move, t2_next_slot = self._opponent_turn(t1_current_pokemon_copy)


        if t1_next_slot is not None:
            self.t1.switch_to(t1_next_slot)

            reward -= 0.1

            if self.print_flag:
                print(f"{self.t1.name} withdraws {t1_current_pokemon_copy.name}")
                print(f"{self.t1.name} sends out {self.t1.current_pokemon.name}")
                self.t1.current_pokemon.just_switched = True


        if t2_next_slot is not None:
            self.t2.switch_to(t2_next_slot)

            if self.print_flag:
                print(f"{self.t2.name} withdraws {t2_current_pokemon_copy.name}")
                print(f"{self.t2.name} sends out {self.t2.current_pokemon.name}")
                self.t2.current_pokemon.just_switched = True

        attacker, attacker_trainer = self.get_turn_order(self.t1.current_pokemon, self.t2.current_pokemon)
        defender, defender_trainer = (self.t2.current_pokemon, self.t2) if attacker_trainer == self.t1 else (self.t1.current_pokemon, self.t1)

        attacker_trainer_move = t1_move if attacker_trainer == self.t1 else t2_move
        defender_trainer_move = t2_move if attacker_trainer == self.t1 else t1_move

        attacker_damage, defender_damage = 0.0, 0.0

        if attacker_trainer_move:
            defender_damage = attacker_trainer_move.calculate_damage(attacker, defender)
            defender.take_damage(defender_damage)

            if self.print_flag:
                print(f"{attacker.name} uses {attacker_trainer_move.name}")
                print(f"Deals {defender_damage:.2f} damage to {defender.name}")


        if defender.is_fainted():

            if self.print_flag:
                print(f"{defender.name} fainted.")

            if defender_trainer.has_usable_pokemon():
                if defender_trainer == self.t1:
                    self.force_switch = True
                else:
                    defender_trainer.send_out_next_pokemon(attacker)
                    if self.print_flag:
                        print(f"{defender_trainer.name} sends out {defender_trainer.current_pokemon.name}")

            else:

                if self.print_flag:
                    print(f"{defender_trainer.name} has no usable Pokémon left.")

                done = True

        else:

            if defender_trainer_move:
                attacker_damage = defender_trainer_move.calculate_damage(defender, attacker)
                attacker.take_damage(attacker_damage)

                if self.print_flag:
                    print(f"{defender.name} uses {defender_trainer_move.name}")
                    print(f"Deals {attacker_damage:.2f} damage to {attacker.name}")

                if attacker.is_fainted():

                    if self.print_flag:
                        print(f"{attacker.name} fainted.")

                    if attacker_trainer.has_usable_pokemon():
                        if attacker_trainer == self.t1:
                            self.force_switch = True
                        else:
                            attacker_trainer.send_out_next_pokemon(defender)
                            if self.print_flag:
                                print(f"{attacker_trainer.name} sends out {attacker_trainer.current_pokemon.name}")
                    else:

                        if self.print_flag:
                            print(f"{attacker_trainer.name} has no usable Pokémon left.")
                        done = True

        opp_fainted = not self.t2.has_usable_pokemon()
        agent_fainted = not self.t1.has_usable_pokemon()

        if opp_fainted or agent_fainted:
            done = True

        opp_alive_after   = self.t2.count_usable_pokemon()
        agent_alive_after = self.t1.count_usable_pokemon()

        if self.print_flag:
            print(f"Remaining of {self.t1.name}: {agent_alive_after}")
            print(f"Remaining of {self.t2.name}: {opp_alive_after}")

        if self.t1.current_pokemon.just_switched:
            self.t1.current_pokemon.just_switched = False
        if self.t2.current_pokemon.just_switched:
            self.t2.current_pokemon.just_switched = False

        agent_damage = attacker_damage if attacker_trainer == self.t1 else defender_damage
        opp_damage = defender_damage if attacker_trainer == self.t1 else attacker_damage

        reward += self._reward_delta(opp_alive_before, opp_alive_after,
                                agent_alive_before, agent_alive_after,
                                agent_damage, opp_damage)

        if self.print_flag:
            print(f"Reward for this turn: {reward:.2f}")

        self.turns += 1

        if self.turns >= self.max_turns:
            done = True
            info = {"timeout": True}
        else:
            info = {}

        if done:
            r_term = +25.0 if opp_fainted else -25.0
            reward += r_term

        return self._encode_state(), reward, done, False, {}

    def get_turn_order(self, p1, p2):
        if p1.speed >= p2.speed:
            return p1, self.t1
        else:
            return p2, self.t2

    def _execute_action(self, trainer, action_idx):

        legal = self.legal_actions(trainer)
        if action_idx not in legal:
            raise ValueError(f"Illegal action {action_idx} for {trainer.name}: "
                            f"legal set = {sorted(legal)}")

        mon = trainer.current_pokemon
        if action_idx <= 3:

            move = mon.moves[action_idx]
            if move.pp_remaining == 0:
              legal_moves = [i for i, mv in enumerate(mon.moves) if mv.pp_remaining > 0]

              if legal_moves:
                  action_idx = int(np.random.choice(legal_moves))
                  move = mon.moves[action_idx]

              else:
                  move = STRUGGLE_MOVE

            return (move, None)
        else:
            slot = action_idx - 4
            if slot < len(trainer.team) and not trainer.team[slot].is_fainted():
                return (None, slot)

    def _opponent_turn(self, agent_pokemon):

        matchup = self.t2.current_pokemon.get_total_matchup_multiplier(agent_pokemon)

        # If in a bad matchup, attempt to switch
        if matchup < 1.0 and random.random() < 1.0:

            best_pokemon_idx = self.t2.get_best_pokemon_idx(agent_pokemon)

            if best_pokemon_idx and self.t2.team[best_pokemon_idx] != self.t2.current_pokemon:

                return (None, best_pokemon_idx)
            else:
                move = self.t2.get_best_move(agent_pokemon)
                return (move, None)
        else:
            move = self.t2.get_best_move(agent_pokemon)
            return (move, None)


    def legal_actions(self, trainer):
        if self.force_switch:
            # can ONLY choose a healthy bench mon
            return [
                4 + j for j, mon in enumerate(trainer.team)
                if not mon.is_fainted() and mon is not trainer.current_pokemon
            ]

        # ── normal turn ──
        actions = []
        for i, mv in enumerate(trainer.current_pokemon.moves):
            if mv.pp_remaining > 0:
                actions.append(i)
        for j, mon in enumerate(trainer.team):
            if not mon.is_fainted() and mon is not trainer.current_pokemon:
                actions.append(4 + j)
        return actions

    def _reward_delta(self, opp_before, opp_after, agent_before, agent_after, agent_damage, opp_damage):
        r = 0.0                 # 0 per turn – remove the tax for now
        r +=  3.0 * (opp_before   - opp_after)   # +3 per KO
        r += -3.0 * (agent_before - agent_after) # -3 per death

        r += 0.01 * opp_damage           # +0.01 per damage dealt
        r -= 0.01 * agent_damage            # -0.01 per damage taken

        r -= 0.01
        if self.turns > self.max_turns // 2:
            r -= 0.1

        return r

    def _encode_state(self):
        # ***Minimal numeric encoding — improve for stronger play***
        def mon_vec(mon):
            hp_pct = mon.hp / mon.max_hp
            type1 = TYPE2IDX[mon.type1]
            type2 = TYPE2IDX.get(mon.type2, 0)
            move_pp = [mv.pp_remaining / mv.pp for mv in mon.moves]
            stats = [mon.attack/300, mon.defense/300,
                     mon.sp_attack/300, mon.sp_defense/300,
                     mon.speed/300]
            return [hp_pct, type1/18, type2/18] + move_pp + stats

        # return np.array(
        #     mon_vec(self.t1.current_pokemon)
        #     + mon_vec(self.t2.current_pokemon)
        #     + [self.turn / self.max_turns],
        #     dtype=np.float32
        # )
        bench_t1 = [m.is_fainted() for m in self.t1.team]
        bench_t2 = [m.is_fainted() for m in self.t2.team]
        return np.array(
            mon_vec(self.t1.current_pokemon) +
            mon_vec(self.t2.current_pokemon) +
            bench_t1 + bench_t2 +
            [self.turns / self.max_turns],
            dtype=np.float32
        )

    def outcome(self) -> dict:
        """Return a compact summary of the finished battle."""
        return {
            "winner":   self.t1.name if self.t1.has_usable_pokemon() else self.t2.name,
            "turns":    self.turns,                       # need to track this; see § 3
            "t1_remaining": sum(not p.is_fainted() for p in self.t1.team),
            "t2_remaining": sum(not p.is_fainted() for p in self.t2.team)
        }


